if !includes.empty?
  preloads = includes.keys.select do |key|
      case includes[key]
      when true
        true
      when Hash
        !(includes[key].keys.any? { |x| ['where', 'limit', 'offset', 'order'].include?(x) })
      else
        false
      end
  end.select { |x| model.reflect_on_all_associations.include?(x) }
  
  instance_variable_set("@#{model.model_name.plural}", instance_variable_get("@#{model.model_name.plural}").preload(preloads))
end

if !includes.empty? && can_cache?(model, includes)
  partial = model_partial(model)
  record_name = partial.split('/').last.to_sym
  locals = { record_name => nil, :includes => includes }
  
  json.cache_collection! instance_variable_get("@#{model.model_name.plural}"), key: proc {|record| cache_key(record, includes) } do |record|
    locals[record_name] = record
    json.partial! partial, locals
  end
else
  json.array! instance_variable_get("@#{model.model_name.plural}"), partial: model_partial(model), as: model_partial(model).split('/').last, includes: includes
end
